// Generated by CoffeeScript 1.6.3
(function() {
  var EventEmitter, LetterBox, Readable, handleMessage, messages,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Readable = require('readable-stream/readable');

  EventEmitter = require('events').EventEmitter;

  messages = new EventEmitter;

  /*
  Emit on the messages emitter that all LetterBoxes close over on the channel that
  the message is targeted at.
  */


  handleMessage = function(event) {
    var error, pkg;
    try {
      pkg = JSON.parse(event.data);
      if ((pkg != null ? pkg._postie : void 0) != null) {
        console.log('emit message');
        return messages.emit(pkg._postie.channel, pkg._postie["package"]);
      }
    } catch (_error) {
      error = _error;
    }
  };

  /*
  We want to do this once, basically rather than having each letterbox register
  their own event listener, just have one that receives and is closed over by all
  the letterboxes.
  */


  if (window.addEventListener) {
    window.addEventListener('message', handleMessage);
  } else {
    window.attachEvent('onmessage', handleMessage);
  }

  /*
  Readable stream that when you start reading from listens to handleMessage and
  then pushes anything it gets. If it tries to push and it can't, it stops
  listening to the emitter.
  */


  LetterBox = (function(_super) {
    __extends(LetterBox, _super);

    /*
    Creates a LetterBox listening to a channel.
    
    - `channel`: A string which is the channel name we're listening to messages
      on.
    */


    function LetterBox(channel) {
      var _this = this;
      this.channel = channel;
      LetterBox.__super__.constructor.call(this, {
        objectMode: true
      });
      messages.on(this.channel, function(data) {
        if (reading) {
          if (!_this.push(data)) {
            return messages.off(_this.name);
          }
        }
      });
    }

    /*
    Internal read function.
    */


    LetterBox.prototype._read = function(size) {
      return this.reading = true;
    };

    return LetterBox;

  })(Readable);

  module.exports = LetterBox;

}).call(this);
